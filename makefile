#Comment next line to show all output to the terminal.
hide = @

#Compiler definitions and flags.
prefix = aarch64-linux-gnu-

assembler = $(prefix)gcc
compiler = $(prefix)g++
linker = $(prefix)ld
objectDumper = $(prefix)objdump
objectCopier = $(prefix)objcopy
c++Filter = $(prefix)c++filt

architecture = -march=armv8-a -mtune=cortex-a53 -mlittle-endian -mcmodel=small
assemblerFlags = $(architecture)
cppFlags = $(architecture) -Wall -Ofast -fno-exceptions -fno-rtti -std=c++14 -fno-builtin -nostdlib -nostdinc

#Definitions of the source code directory and the object directory, where all generated files will be stored.
sourceDirectory = sourceCode
objectDirectory = compiledCode

#Naming of some specific source and object files.
linkerDescription = linkerDescription
imageName = kernel8

#Find all subdirectories in the sourceDirectory and use them to generate the same directory tree for in the
#objectDirectory and to generate all include directives for compiling.
sourceDirectories = $(shell find $(sourceDirectory) -type d)
objectDirectories = $(patsubst $(sourceDirectory)%,$(objectDirectory)%,$(sourceDirectories))
includeDirectories = $(patsubst %,-I%,$(sourceDirectories))

#Find all paths of the source files and use them to generate equivalent paths for the object and dependency files.
sources = $(shell find $(sourceDirectory) -name "*.cpp") $(shell find $(sourceDirectory) -name "*.S")
objects = $(patsubst %.cpp,%.o,$(sources))
objects := $(patsubst %.S,%.o,$(objects))
objects := $(patsubst $(sourceDirectory)%,$(objectDirectory)%,$(objects))
dependencies = $(patsubst %.o,%.d,$(objects))

#Build image file and all its dependencies.
all: $(objectDirectory)/directoriesExist $(objectDirectory)/$(imageName).img

#Make all subirectories where the object files will go, otherwise you will get a missing folder complaint when
#compiling. Add an empty file in the root of the objectDirectory, so you have a dependency and have to run this
#rule only once.
$(objectDirectory)/directoriesExist:
	$(info Creating directories for object files.)
	$(hide)mkdir -p $(objectDirectories)
	$(hide)touch $(objectDirectory)/directoriesExist

#Link all object and startup files to one elf file and convert it to a binary image file. Remove the elf file to avoid
#cluttering the object directory.
$(objectDirectory)/$(imageName).img: $(sourceDirectory)/$(linkerDescription).ld $(objects)
	$(info Link all objects and generate the image file: $(imageName).img.)
	$(hide)$(linker) -o $(objectDirectory)/$(imageName).elf -T $(sourceDirectory)/$(linkerDescription).ld $(objects)
	$(hide)$(objectCopier) $(objectDirectory)/$(imageName).elf -O binary $(objectDirectory)/$(imageName).img
	$(hide)rm $(objectDirectory)/$(imageName).elf

#Include all generated dependency files, which include rules for recompiling a source file when one of its included
#header files has changed.
-include $(dependencies)

#Compile all S source files in the project.
#The first rule outputs which file is compiled. If the hide option is active this is the only line that will be
#displayed, to avoid an overload of information. The second rule is a generic rule for actully compiling the object
#file from the source file. The third rule generates a dependecy file that is later used for checking changes in
#header files that are included by the source file. The last four rules are to modify the dependency file. The
#target in this file is generated in the form "object.o", which wont work cause we need the full path, so it is
#converted to the form "subDirectory/subDirectory/object.o".
$(objectDirectory)/%.o: $(sourceDirectory)/%.S
	$(info Compile source file: $<.)
	$(hide)$(assembler) $(assemblerFlags) $(includeDirectories) -c -o $@ $<
	$(hide)$(assembler) $(includeDirectories) -MM $(sourceDirectory)/$*.S > $(objectDirectory)/$*.d
	$(hide)cp -f $(objectDirectory)/$*.d $(objectDirectory)/$*.d.tmp
	$(hide)sed -e 's|.*:|$(objectDirectory)/$*.o:|' < $(objectDirectory)/$*.d.tmp > $(objectDirectory)/$*.d
	$(hide)sed -e 's/.*://' -e 's/\\$$//' < $(objectDirectory)/$*.d.tmp | fmt -1 | sed -e 's/^ *//' -e 's/$$/:/' >> $(objectDirectory)/$*.d
	$(hide)rm -f $(objectDirectory)/$*.d.tmp

#Compile all cpp source files in the project the same way as the S files.
$(objectDirectory)/%.o: $(sourceDirectory)/%.cpp
	$(info Compile source file: $<.)
	$(hide)$(compiler) $(cppFlags) $(includeDirectories) -c -o $@ $<
	$(hide)$(compiler) $(includeDirectories) -MM $(sourceDirectory)/$*.cpp > $(objectDirectory)/$*.d
	$(hide)cp -f $(objectDirectory)/$*.d $(objectDirectory)/$*.d.tmp
	$(hide)sed -e 's|.*:|$(objectDirectory)/$*.o:|' < $(objectDirectory)/$*.d.tmp > $(objectDirectory)/$*.d
	$(hide)sed -e 's/.*://' -e 's/\\$$//' < $(objectDirectory)/$*.d.tmp | fmt -1 | sed -e 's/^ *//' -e 's/$$/:/' >> $(objectDirectory)/$*.d
	$(hide)rm -f $(objectDirectory)/$*.d.tmp

#Remove everything generated by the make command, so next time everything is recompiled.
clean:
	$(info Removed entire $(objectDirectory) folder.)
	$(hide)rm -r $(objectDirectory)

#Define all targets that aren't actually files.
.PHONY: all clean
